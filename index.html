<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bulk Image Organizer — Upload · Reorder · Rename · Download</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0f14; --panel:#121821; --muted:#1a2230; --text:#e8eef6; --text-dim:#a7b3c6; --accent:#4da3ff; --accent-2:#22c55e; --danger:#ef4444; --warning:#f59e0b;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; background:var(--bg); color:var(--text);
  }
  header{
    position:sticky; top:0; z-index:20; background:linear-gradient(180deg,var(--panel),#0f141c); border-bottom:1px solid #1f2a3b;
  }
  .wrap{max-width:15000px; margin:0 auto; padding:16px;}
  h1{font-size:20px; margin:0 0 8px;}
  .toolbar{display:grid; grid-template-columns:1fr; gap:12px;}
  .controls{display:flex; flex-wrap:wrap; gap:8px; align-items:center}
  .control{background:var(--muted); border:1px solid #233044; border-radius:10px; padding:8px 10px; display:flex; align-items:center; gap:8px}
  .control label{font-size:12px; color:var(--text-dim)}
  .control input[type="text"], .control input[type="number"]{background:#0d131b; color:var(--text); border:1px solid #223146; padding:6px 8px; border-radius:8px; min-width:80px}
  .buttons{display:flex; flex-wrap:wrap; gap:8px}
  button{background:#162132; color:var(--text); border:1px solid #233044; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600}
  button:hover{border-color:#2f405a}
  .primary{background:linear-gradient(180deg,#1f3a5f,#1a2f4f); border-color:#2e5ea7}
  .primary:hover{border-color:#3b79d9}
  .success{background:linear-gradient(180deg,#123324,#102a1e); border-color:#107e46}
  .danger{background:linear-gradient(180deg,#3b1111,#2d0d0d); border-color:#7a1d1d}
  .muted{opacity:.8}
  .hint{font-size:10px; color:var(--text-dim); line-height:1.6;}
  
  .dropzone{margin-top:12px; background:repeating-linear-gradient(45deg, #141b26 0 10px, #121821 10px 20px);
    border:2px dashed #314159; border-radius:14px; padding:22px; text-align:center}
  .dropzone.dragover{border-color:var(--accent)}
  .dropzone input{display:none}
  .dropzone .big{font-size:14px; color:var(--text-dim)}
  
  main{max-width:15000px; margin:12px auto; padding:0 16px 32px}
  .gallery{display:grid; grid-template-columns:repeat(auto-fill,minmax(140px,1fr)); gap:12px}
  .tile{position:relative; background:#0f141c; border:1px solid #1f2a3b; border-radius:14px; overflow:hidden; outline:none; display:block}
  .tile.selected{border-color:#4da3ff; box-shadow:0 0 0 2px #4da3ff33}
  .tile.multi-dragging{opacity:0.7; transform:scale(1.05)}
  .deselect-all{position:absolute; right:6px; bottom:6px; width:20px; height:20px; border-radius:4px; border:none; background:#4da3ff; color:white; display:flex; align-items:center; justify-content:center; font-weight:600; cursor:pointer; z-index:10; font-size:10px; line-height:1; padding:0}
  .deselect-all:hover{background:#3b79d9}
  .deselect-all:focus{outline:2px solid #fff3}
  .thumb{display:block; width:100%; height:auto; object-fit:contain; background:#0b1018; max-height:300px; user-select:none; -webkit-user-drag:none}
  .filename{font-size:11px; padding:6px 8px; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; color:var(--text-dim); border-top:1px solid #1a2230; background:#0f141c; user-select:none; pointer-events:none}
  .badge{position:absolute; left:6px; top:6px; background:#0b1220cc; color:#cde3ff; border:1px solid #234; padding:3px 6px; border-radius:999px; font-size:11px; backdrop-filter: blur(3px); pointer-events:none; user-select:none}
  .remove{position:absolute; right:6px; top:6px; width:26px; height:26px; border-radius:50%; border:none; background:#ff3344; color:white; display:flex; align-items:center; justify-content:center; font-weight:900; cursor:pointer; z-index:10; font-size:14px; line-height:1}
  .remove:hover{filter:brightness(1.1)}
  .remove:focus{outline:2px solid #fff3}
  .drag-handle{position:absolute; left:6px; bottom:6px; font-size:11px; background:#0b1220cc; color:#cde3ff; border:1px dashed #345; padding:2px 6px; border-radius:8px; cursor:grab; user-select:none}
  .drag-handle:hover{background:#1a2a3f; border-color:#456}
  .drag-handle:active{cursor:grabbing}
  
  /* Native HTML5 drag styles */
  .tile{cursor:grab; transition: all 0.2s ease}
  .tile:hover{border-color:#2f405a; transform:scale(1.02)}
  .tile[draggable="true"]:active{cursor:grabbing}
  .tile.dragging{opacity:0.5; transform:rotate(2deg) scale(1.05)}
  
  .footer{margin-top:16px; display:flex; justify-content:space-between; align-items:center; gap:12px}
  .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0}
  
  @media (max-width:720px){
    .controls{gap:6px}
    .control{width:100%}
    .buttons{width:100%}
    .buttons button{flex:1}
    .gallery{grid-template-columns:repeat(auto-fill,minmax(120px,1fr))}
  }
  
  @media (min-width:1400px){
    .gallery{grid-template-columns:repeat(auto-fill,minmax(120px,1fr))}
  }
  
  @media (min-width:1800px){
    .gallery{grid-template-columns:repeat(auto-fill,minmax(100px,1fr))}
  }
</style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Bulk Image Organizer</h1>
      <div class="toolbar">
        <div class="controls" role="group" aria-label="Naming controls">
          <div class="control">
            <label for="prefix">Name prefix</label>
            <input id="prefix" type="text" placeholder="e.g. character" aria-label="Filename prefix" />
          </div>
          <div class="control">
            <label for="start">Start #</label>
            <input id="start" type="number" value="1" min="0" step="1" aria-label="Starting number"/>
          </div>
          <div class="control">
            <label for="pad">Padding ###</label>
            <input id="pad" type="number" value="3" min="1" max="8" step="1" aria-label="Zero pad digits"/>
          </div>
          <div class="control">
            <label for="sep">Separator</label>
            <input id="sep" type="text" value="-" maxlength="2" aria-label="Separator between prefix and number"/>
          </div>
          <div class="control">
            <label for="ext">Example:</label>
            <span class="hint">Character-001.png </span>
          </div>
        </div>
        <div class="buttons" role="group" aria-label="Actions">
          <button id="btnUpload" class="primary" title="Upload images" aria-label="Upload images">Upload Images</button>
          <button id="btnUndo" class="muted" aria-label="Undo" title="Undo last action">↶ Undo</button>
          <button id="btnRedo" class="muted" aria-label="Redo" title="Redo last undo">↷ Redo</button>
          <button id="btnClear" class="danger" aria-label="Clear all" title="Remove all images">Clear All</button>
          <button id="btnDownloadEach" class="success" aria-label="Download each" title="Download all (individual files)">Download Individually</button>
          <button id="btnZip" class="success" aria-label="Download zip" title="Download all (ZIP, recommended)">Download as ZIP</button>
          <span class="hint" id="count">0 images</span>
        </div>
      </div>
      <div id="drop" class="dropzone" role="button" tabindex="0" aria-label="Dropzone: click or drag files here">
        <p class="big">Drag & drop images here (optimally >200), or <strong>click here to upload</strong>.</p>
        <input id="fileInput" type="file" accept="image/*" multiple aria-label="File picker" />
      </div>
    </div>
  </header>

  <main>
    <section class="wrap">
      <div id="gallery" class="gallery" aria-live="polite"></div>
      <div class="footer">
        <div class="hint">
          Tip: drag tiles to reorder. Ctrl click to select multiple then drag. The number badge shows the current sequence. Use Undo/Redo (Ctrl Z/Y) if you make a mistake.<br>
          Individual file download is optimal at 200. Zipped file downloads are optimal at 1000.
        <div class="hint" id="sizeInfo"></div>
      </div>
    </section>
  </main>

  <!-- Native HTML5 drag and drop implementation -->
  <!-- JSZip for zipping downloads -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
  // Data model for an item
  // { id: string, file: File, url: objectURL, name: original name }
  const state = {
    items: [],             // ordered array of ids
    byId: new Map(),       // id -> item
    undo: [],
    redo: [],
    totalBytes: 0,
    selectedItems: new Set(), // selected item ids for multi-select
  };

  const el = {
    gallery: document.getElementById('gallery'),
    drop: document.getElementById('drop'),
    input: document.getElementById('fileInput'),
    btnUpload: document.getElementById('btnUpload'),
    btnUndo: document.getElementById('btnUndo'),
    btnRedo: document.getElementById('btnRedo'),
    btnClear: document.getElementById('btnClear'),
    btnDownloadEach: document.getElementById('btnDownloadEach'),
    btnZip: document.getElementById('btnZip'),
    count: document.getElementById('count'),
    prefix: document.getElementById('prefix'),
    start: document.getElementById('start'),
    pad: document.getElementById('pad'),
    sep: document.getElementById('sep'),
    sizeInfo: document.getElementById('sizeInfo'),
  };

  function humanBytes(n){
    if(!n) return '0 B';
    const k = 1024; const units = ['B','KB','MB','GB'];
    const i = Math.floor(Math.log(n)/Math.log(k));
    return (n/Math.pow(k,i)).toFixed(1)+' '+units[i];
  }

  function pushHistory(){
    // Save a complete snapshot of current state
    const snap = {
      items: [...state.items],
      byId: new Map(state.byId),
      totalBytes: state.totalBytes,
      selectedItems: new Set(state.selectedItems),
    };
    state.undo.push(snap);
    // Cap history to 50 changes
    if(state.undo.length > 50) state.undo.shift();
    // Clear redo on new action
    state.redo.length = 0;
    updateUndoRedoButtons();
  }

  function restoreSnapshot(snap){
    // Clean up old object URLs before restoring
    for(const id of state.items) {
      if(!snap.byId.has(id)) {
        const item = state.byId.get(id);
        if(item && item.url) URL.revokeObjectURL(item.url);
      }
    }
    
    // Restore complete state
    state.items = [...snap.items];
    state.byId = new Map(snap.byId);
    state.totalBytes = snap.totalBytes;
    state.selectedItems = new Set(snap.selectedItems);
    
    renderGallery();
    updateUndoRedoButtons();
  }

  function updateUndoRedoButtons(){
    el.btnUndo.disabled = state.undo.length===0;
    el.btnRedo.disabled = state.redo.length===0;
    el.count.textContent = `${state.items.length} image${state.items.length===1?'':'s'}`;
    el.sizeInfo.textContent = state.totalBytes?`Total size: ${humanBytes(state.totalBytes)}`:'';
  }

  function addFiles(fileList){
    const files = Array.from(fileList).filter(f=>f && f.type.startsWith('image/'));
    if(!files.length) return;
    
    // Sort files by filename to maintain order
    files.sort((a, b) => {
      return a.name.localeCompare(b.name, undefined, {
        numeric: true,
        sensitivity: 'base'
      });
    });
    
    pushHistory();
    for(const file of files){
      const id = crypto.randomUUID();
      const url = URL.createObjectURL(file);
      state.byId.set(id, {id, file, url, name:file.name});
      state.items.push(id);
      state.totalBytes += file.size;
    }
    renderGallery();
  }

  function removeItem(id, opts={}){
    const item = state.byId.get(id);
    if(!item) return;
    if(!opts.skipHistory) pushHistory();
    state.items = state.items.filter(x=>x!==id);
    state.byId.delete(id);
    state.selectedItems.delete(id);
    URL.revokeObjectURL(item.url);
    state.totalBytes -= item.file.size || 0;
    const tile = document.getElementById(`tile-${id}`);
    if(tile) tile.remove();
    updateIndices();
    updateUndoRedoButtons();
  }

  function clearAll(){
    if(!state.items.length) return;
    pushHistory();
    for(const id of state.items){
      const {url} = state.byId.get(id);
      URL.revokeObjectURL(url);
    }
    state.items = [];
    state.byId.clear();
    state.selectedItems.clear();
    state.totalBytes = 0;
    renderGallery();
  }

  function renderGallery(){
    // Efficient render: build fragment
    el.gallery.innerHTML = '';
    const frag = document.createDocumentFragment();
    const selectedArray = Array.from(state.selectedItems);
    const firstSelectedId = selectedArray.length > 0 ? selectedArray[0] : null;
    
    for(const [index, id] of state.items.entries()){
      const item = state.byId.get(id);
      if(!item) continue;
      const tile = document.createElement('div');
      tile.className = 'tile';
      if(state.selectedItems.has(id)) tile.classList.add('selected');
      tile.id = `tile-${id}`;
      tile.tabIndex = 0;
      tile.setAttribute('role','group');
      tile.setAttribute('aria-label', `Image ${index+1}: ${item.name}`);
      tile.setAttribute('draggable', 'true');
      tile.dataset.index = index;
      tile.dataset.id = id;

      const img = document.createElement('img');
      img.className = 'thumb';
      img.src = item.url;
      img.alt = item.name;

      const badge = document.createElement('div');
      badge.className = 'badge';
      badge.textContent = String(index+1);
      badge.setAttribute('aria-hidden','true');

      const rm = document.createElement('button');
      rm.className = 'remove';
      rm.type = 'button';
      rm.setAttribute('aria-label','Remove image');
      rm.title = 'Remove';
      rm.innerHTML = '✕';
      rm.addEventListener('click', (e)=> {
        e.stopPropagation();
        removeItem(id);
      });

      const handle = document.createElement('div');
      handle.className = 'drag-handle';
      handle.textContent = '⇅ drag';

      const fn = document.createElement('div');
      fn.className = 'filename';
      fn.textContent = item.name;

      // Add deselect all button only to the first selected item
      if(id === firstSelectedId && selectedArray.length > 1) {
        const deselectBtn = document.createElement('button');
        deselectBtn.className = 'deselect-all';
        deselectBtn.type = 'button';
        deselectBtn.setAttribute('aria-label','Deselect all');
        deselectBtn.title = 'Deselect all';
        deselectBtn.innerHTML = '✓';
        deselectBtn.addEventListener('click', (e)=> {
          e.stopPropagation();
          state.selectedItems.clear();
          document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
          renderGallery(); // Re-render to remove deselect buttons
        });
        tile.appendChild(deselectBtn);
      }

      // Add click handler for selection
      tile.addEventListener('click', (e) => {
        if(e.ctrlKey || e.metaKey) {
          e.preventDefault();
          if(state.selectedItems.has(id)) {
            state.selectedItems.delete(id);
            tile.classList.remove('selected');
          } else {
            state.selectedItems.add(id);
            tile.classList.add('selected');
          }
          // Re-render to update deselect button placement
          renderGallery();
        } else {
          // Clear selection if not holding Ctrl
          state.selectedItems.clear();
          document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
          renderGallery();
        }
      });

      tile.append(img, badge, rm, handle, fn);
      frag.appendChild(tile);
    }
    el.gallery.appendChild(frag);
    enableDragAndDrop();
    updateUndoRedoButtons();
  }

  function enableDragAndDrop() {
    const tiles = document.querySelectorAll('.tile');
    let dragged;
    let draggedItems = [];

    // Enable scroll during drag
    let isDragging = false;
    document.addEventListener('dragstart', () => { isDragging = true; });
    document.addEventListener('dragend', () => { isDragging = false; });
    
    // Allow scroll wheel during drag
    document.addEventListener('wheel', (e) => {
      if(isDragging) {
        // Don't prevent default - allow normal scrolling
        return;
      }
    }, { passive: true });

    tiles.forEach(tile => {
      tile.addEventListener('dragstart', (e) => {
        dragged = tile;
        const draggedId = tile.dataset.id;
        
        // If dragging a selected item, drag all selected items
        if(state.selectedItems.has(draggedId) && state.selectedItems.size > 1) {
          draggedItems = Array.from(state.selectedItems);
          // Mark all selected items as being dragged
          state.selectedItems.forEach(id => {
            const selectedTile = document.getElementById(`tile-${id}`);
            if(selectedTile) selectedTile.classList.add('multi-dragging');
          });
        } else {
          draggedItems = [draggedId];
          tile.style.opacity = '0.5';
        }
        
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', draggedItems.join(','));
        console.log('Drag started for items:', draggedItems);
      });

      tile.addEventListener('dragend', (e) => {
        tile.style.opacity = '';
        // Remove multi-dragging class from all tiles
        document.querySelectorAll('.tile.multi-dragging').forEach(t => {
          t.classList.remove('multi-dragging');
        });
        console.log('Drag ended');
      });

      tile.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        tile.style.borderColor = '#4da3ff';
      });

      tile.addEventListener('dragleave', (e) => {
        tile.style.borderColor = '';
      });

      tile.addEventListener('drop', (e) => {
        e.preventDefault();
        tile.style.borderColor = '';
        
        if (dragged && dragged !== tile && draggedItems.length > 0) {
          const targetId = tile.dataset.id;
          console.log('Dropping items', draggedItems, 'onto', targetId);
          
          // Save current state for undo
          pushHistory();
          
          // Find target index
          const targetIndex = state.items.findIndex(id => id === targetId);
          if (targetIndex === -1) return;
          
          // Remove all dragged items from their current positions
          const itemsToMove = [];
          for(const draggedId of draggedItems) {
            const index = state.items.findIndex(id => id === draggedId);
            if(index !== -1) {
              itemsToMove.push({ id: draggedId, originalIndex: index });
            }
          }
          
          // Sort by original index in reverse order to remove from end first
          itemsToMove.sort((a, b) => b.originalIndex - a.originalIndex);
          
          // Remove items from state.items
          for(const item of itemsToMove) {
            state.items.splice(item.originalIndex, 1);
          }
          
          // Find new target index after removals
          const newTargetIndex = state.items.findIndex(id => id === targetId);
          if(newTargetIndex === -1) return;
          
          // Insert all moved items at the target position
          // Reverse the order to maintain relative positions
          const itemIds = itemsToMove.reverse().map(item => item.id);
          state.items.splice(newTargetIndex, 0, ...itemIds);
          
          // Keep selection after move - don't clear selectedItems
          
          // Re-render gallery
          renderGallery();
        }
      });
    });
  }

  function updateIndices(){
    Array.from(el.gallery.children).forEach((ch, i)=>{
      const badge = ch.querySelector('.badge');
      if(badge) badge.textContent = String(i+1);
    });
    updateUndoRedoButtons();
  }

  // Naming helpers
  function computeFilename(i, ext){
    const prefix = el.prefix.value || '';
    const start = parseInt(el.start.value||'1',10)||0;
    const pad = Math.min(8, Math.max(1, parseInt(el.pad.value||'3',10)));
    const sep = el.sep.value ?? '-';
    const num = String(start + i).padStart(pad,'0');
    return `${prefix}${sep}${num}${ext}`;
  }

  // Download: individual files with enhanced reliability
  async function downloadIndividually(){
    if(!state.items.length) return;
    
    console.log(`Starting download of ${state.items.length} files...`);
    const startTime = Date.now();
    let successCount = 0;
    let failCount = 0;
    
    // Update button to show progress
    const originalText = el.btnDownloadEach.textContent;
    el.btnDownloadEach.disabled = true;
    
    // Process downloads with retry logic
    for(let i = 0; i < state.items.length; i++){
      const id = state.items[i];
      const item = state.byId.get(id);
      if(!item) {
        failCount++;
        continue;
      }
      
      let downloadAttempts = 0;
      const maxAttempts = 3;
      let downloadSucceeded = false;
      
      while(downloadAttempts < maxAttempts && !downloadSucceeded) {
        try {
          const ext = item.file.name.match(/\.[A-Za-z0-9]+$/)?.[0] || '';
          const name = computeFilename(i, ext);
          
          // Create fresh blob URL for each attempt
          const blobUrl = URL.createObjectURL(item.file);
          
          // Create download link
          const a = document.createElement('a');
          a.href = blobUrl;
          a.download = name;
          a.style.display = 'none';
          document.body.appendChild(a);
          
          // Trigger download with verification
          a.click();
          
          // Wait to ensure download starts
          await new Promise(r => setTimeout(r, 200));
          
          // Clean up
          document.body.removeChild(a);
          setTimeout(() => URL.revokeObjectURL(blobUrl), 2000);
          
          downloadSucceeded = true;
          successCount++;
          
          // Update progress
          el.btnDownloadEach.textContent = `Downloading... ${i + 1}/${state.items.length}`;
          
          // Delay between successful downloads
          await new Promise(r => setTimeout(r, 250));
          
        } catch (error) {
          downloadAttempts++;
          console.error(`Download attempt ${downloadAttempts} failed for file ${i + 1}:`, error);
          
          if(downloadAttempts < maxAttempts) {
            // Wait before retry
            await new Promise(r => setTimeout(r, 500));
          } else {
            failCount++;
          }
        }
      }
    }
    
    // Restore button
    el.btnDownloadEach.disabled = false;
    el.btnDownloadEach.textContent = originalText;
    
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    console.log(`Download completed: ${successCount} successful, ${failCount} failed in ${elapsed}s`);
    
    if (failCount > 0) {
      alert(`Download completed with issues: ${successCount} files downloaded successfully, ${failCount} failed. Consider using ZIP download for better reliability.`);
    } else {
      console.log(`All ${successCount} files downloaded successfully!`);
    }
  }

  // Download: ZIP with better error handling and progress
  async function downloadZip(){
    if(!state.items.length) return;
    
    console.log(`Creating ZIP with ${state.items.length} files...`);
    const originalText = el.btnZip.textContent;
    el.btnZip.disabled = true;
    el.btnZip.textContent = 'Creating ZIP...';
    
    try {
      const zip = new JSZip();
      let processedCount = 0;
      
      // Process files in smaller batches to avoid memory issues
      const batchSize = 20;
      for (let i = 0; i < state.items.length; i += batchSize) {
        const batch = state.items.slice(i, i + batchSize);
        
        const batchPromises = batch.map(async (id, batchIndex) => {
          const globalIndex = i + batchIndex;
          const item = state.byId.get(id);
          if (!item) return;
          
          try {
            const ext = item.file.name.match(/\.[A-Za-z0-9]+$/)?.[0] || '';
            const name = computeFilename(globalIndex, ext);
            const arrayBuffer = await item.file.arrayBuffer();
            zip.file(name, arrayBuffer);
            processedCount++;
            
            // Update progress
            el.btnZip.textContent = `Processing... ${processedCount}/${state.items.length}`;
          } catch (error) {
            console.error(`Failed to process file ${globalIndex + 1}:`, error);
          }
        });
        
        await Promise.all(batchPromises);
        
        // Small delay between batches
        if (i + batchSize < state.items.length) {
          await new Promise(r => setTimeout(r, 50));
        }
      }
      
      console.log(`Processed ${processedCount} files, generating ZIP...`);
      el.btnZip.textContent = 'Generating ZIP...';
      
      // Generate ZIP with compression
      const blob = await zip.generateAsync({
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
      });
      
      // Create download
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      const zipPrefix = el.prefix.value || 'images';
      a.download = `${zipPrefix}-renamed.zip`;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      
      // Cleanup
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }, 1000);
      
      console.log(`ZIP download successful: ${processedCount} files included`);
      
    } catch (error) {
      console.error('ZIP creation failed:', error);
      alert('Failed to create ZIP file. Please try individual downloads or reduce the number of files.');
    } finally {
      // Restore button
      el.btnZip.disabled = false;
      el.btnZip.textContent = originalText;
    }
  }

  // Undo/Redo with proper state management
  el.btnUndo.addEventListener('click', ()=>{
    if(!state.undo.length) return;
    
    // Save current state to redo stack
    const currentSnap = {
      items: [...state.items],
      byId: new Map(state.byId),
      totalBytes: state.totalBytes,
      selectedItems: new Set(state.selectedItems),
    };
    state.redo.push(currentSnap);
    
    // Cap redo history to 50
    if(state.redo.length > 50) state.redo.shift();
    
    // Restore previous state
    const snap = state.undo.pop();
    restoreSnapshot(snap);
  });

  el.btnRedo.addEventListener('click', ()=>{
    if(!state.redo.length) return;
    
    // Save current state to undo stack
    const currentSnap = {
      items: [...state.items],
      byId: new Map(state.byId),
      totalBytes: state.totalBytes,
      selectedItems: new Set(state.selectedItems),
    };
    state.undo.push(currentSnap);
    
    // Cap undo history to 50
    if(state.undo.length > 50) state.undo.shift();
    
    // Restore next state
    const snap = state.redo.pop();
    restoreSnapshot(snap);
  });

  // Upload handling
  function openPicker(){ el.input.click(); }
  el.btnUpload.addEventListener('click', openPicker);
  el.drop.addEventListener('click', (e)=>{
    if(e.target.id==='fileInput') return; // let native picker work
    openPicker();
  });
  el.input.addEventListener('change', (e)=> addFiles(e.target.files));

  // Drag & drop
  ;['dragenter','dragover'].forEach(type=> el.drop.addEventListener(type, (e)=>{
    e.preventDefault(); e.stopPropagation(); el.drop.classList.add('dragover');
  }));
  ;['dragleave','drop'].forEach(type=> el.drop.addEventListener(type, (e)=>{
    e.preventDefault(); e.stopPropagation(); el.drop.classList.remove('dragover');
  }));
  el.drop.addEventListener('drop', (e)=>{
    const files = e.dataTransfer.files;
    addFiles(files);
  });

  // Clear all
  el.btnClear.addEventListener('click', ()=>{
    if(confirm('Remove all images?')) clearAll();
  });

  // Downloads
  el.btnDownloadEach.addEventListener('click', downloadIndividually);
  el.btnZip.addEventListener('click', downloadZip);

  // Keyboard accessibility: Delete removes focused tile, Escape clears selection, Ctrl+Z/Y for undo/redo
  el.gallery.addEventListener('keydown', (e)=>{
    if((e.key==='Delete' || e.key==='Backspace') && document.activeElement.classList.contains('tile')){
      const id = document.activeElement.id.replace('tile-','');
      removeItem(id);
    }
    if(e.key==='Escape') {
      // Clear selection
      state.selectedItems.clear();
      document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
      renderGallery(); // Re-render to remove deselect buttons
    }
  });

  // Global keyboard shortcuts for undo/redo
  document.addEventListener('keydown', (e) => {
    // Ctrl+Z for undo
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
      e.preventDefault();
      if (state.undo.length > 0) {
        el.btnUndo.click();
      }
    }
    // Ctrl+Y for redo
    else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
      e.preventDefault();
      if (state.redo.length > 0) {
        el.btnRedo.click();
      }
    }
  });

  // Persist minimal settings (prefix, pad, start, sep)
  const loadSettings = () => {
    try{
      const s = JSON.parse(localStorage.getItem('bulkImageOrganizerSettings')||'{}');
      if(s.prefix!==undefined) el.prefix.value = s.prefix;
      if(s.start!==undefined) el.start.value = s.start;
      if(s.pad!==undefined) el.pad.value = s.pad;
      if(s.sep!==undefined) el.sep.value = s.sep;
    }catch{}
  };
  const saveSettings = () => {
    const s = {prefix:el.prefix.value, start:el.start.value, pad:el.pad.value, sep:el.sep.value};
    localStorage.setItem('bulkImageOrganizerSettings', JSON.stringify(s));
  };
  ['input','change'].forEach(ev=>{
    el.prefix.addEventListener(ev, saveSettings);
    el.start.addEventListener(ev, saveSettings);
    el.pad.addEventListener(ev, saveSettings);
    el.sep.addEventListener(ev, saveSettings);
  });
  loadSettings();

  // Informative: performance hint for huge batches
  console.log('%cTip','background:#1f2937;color:#93c5fd;padding:4px 6px;border-radius:6px', 'For 150+ images, ZIP download is recommended to avoid popup blockers.');
  </script>
</body>
</html>
